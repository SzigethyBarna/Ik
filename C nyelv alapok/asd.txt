lancolt lista
#include <stdio.h>
#include <stdlib.h>

/*
    Egy bináris keresőfa csomópontja.
    - dist: a tárolt érték
    - left: bal gyerek
    - right: jobb gyerek
*/
typedef struct Node {
    int dist;
    struct Node *left;
    struct Node *right;
} Node;

/*
    Új csomópont létrehozása
*/
Node *create_node(int dist) {
    Node *n = malloc(sizeof(Node));
    if (!n) {
        return NULL;
    }

    n->dist = dist;
    n->left = NULL;
    n->right = NULL;
    return n;
}

/*
    Elem beszúrása a bináris keresőfába
*/
Node *insert(Node *root, int dist) {
    // Ha üres helyet találtunk, ide szúrunk
    if (root == NULL) {
        return create_node(dist);
    }

    // Kisebb érték balra kerül
    if (dist < root->dist) {
        root->left = insert(root->left, dist);
    }
    // Nagyobb érték jobbra kerül
    else if (dist > root->dist) {
        root->right = insert(root->right, dist);
    }
    // Egyenlő értéket nem szúrunk be

    return root;
}

/*
    Fa kiírása inorder bejárással
    (bal - gyökér - jobb)
    Ez rendezett sorrendet ad
*/
void print_tree(Node *root) {
    if (root == NULL) {
        return;
    }

    print_tree(root->left);
    printf("%d\n", root->dist);
    print_tree(root->right);
}

/*
    Elem törlése a fából
    Csak 0 vagy 1 gyerekes esetet kezelünk
*/
Node *delete_node(Node *root, int dist) {
    if (root == NULL) {
        return NULL;
    }

    if (dist < root->dist) {
        root->left = delete_node(root->left, dist);
    }
    else if (dist > root->dist) {
        root->right = delete_node(root->right, dist);
    }
    else {
        // Megtaláltuk a törlendő elemet

        // Nincs bal gyerek
        if (root->left == NULL) {
            Node *tmp = root->right;
            free(root);
            return tmp;
        }

        // Nincs jobb gyerek
        if (root->right == NULL) {
            Node *tmp = root->left;
            free(root);
            return tmp;
        }

        // Két gyerekes esetet nem kezeljük (ZH-n elfogadott)
    }

    return root;
}

/*
    A teljes fa felszabadítása
*/
void free_tree(Node *root) {
    if (root == NULL) {
        return;
    }

    free_tree(root->left);
    free_tree(root->right);
    free(root);
}

/*
    Főprogram – menüvezérelt működés
*/
int main() {
    Node *root = NULL;
    int choice;
    int x;

    while (1) {
        printf("\nMENÜ:\n");
        printf("1 - Elem beszúrása\n");
        printf("2 - Fa kiírása (rendezve)\n");
        printf("3 - Elem törlése\n");
        printf("4 - Kilépés\n");
        printf("Választás: ");

        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Beszúrandó szám: ");
                scanf("%d", &x);
                root = insert(root, x);
                break;

            case 2:
                printf("Fa elemei:\n");
                print_tree(root);
                break;

            case 3:
                printf("Törlendő szám: ");
                scanf("%d", &x);
                root = delete_node(root, x);
                break;

            case 4:
                free_tree(root);
                printf("Kilépés.\n");
                return 0;

            default:
                printf("Hibás választás!\n");
        }
    }
}

nem lancolt lista:

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "library.h"

void menu(void) {
    Loan *loans = NULL;
    int count = 0;

    char filename[100];
    char title[200];
    char borrower[200];
    int year, days;

    printf("Fajl neve: ");
    scanf("%99s", filename);

    FILE *f = fopen(filename, "r");
    if (!f) {
        perror("Nem lehet megnyitni");
        return;
    }

    /* ===== FÁJL BEOLVASÁS ===== */
    while (fgets(title, 200, f) != NULL) {
        title[strcspn(title, "\n")] = 0;

        if (fgets(borrower, 200, f) == NULL)
            break;
        borrower[strcspn(borrower, "\n")] = 0;

        if (fscanf(f, "%d %d", &year, &days) != 2)
            break;
        fgetc(f);

        if (year < 2000 || days <= 0 || days > 60)
            continue;

        Loan *tmp = realloc(loans, (count + 1) * sizeof(Loan));
        if (!tmp) break;
        loans = tmp;

        loans[count].title = malloc(strlen(title) + 1);
        loans[count].borrower = malloc(strlen(borrower) + 1);

        strcpy(loans[count].title, title);
        strcpy(loans[count].borrower, borrower);

        loans[count].year = year;
        loans[count].days = days;
        count++;
    }
    fclose(f);

    /* ===== MENÜ ===== */
    int choice;
    do {
        printf("\n1 - Osszes kolcsonzes\n");
        printf("2 - 2023-as kolcsonzesek\n");
        printf("3 - Hosszu kolcsonzesek (30+ nap)\n");
        printf("4 - Atlagos kolcsonzesi ido\n");
        printf("5 - Uj kolcsonzes\n");
        printf("6 - Kilepes\n");
        printf("Valasztas: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                list_all(loans, count);
                break;
            case 2:
                list_2023(loans, count);
                break;
            case 3:
                list_long(loans, count);
                break;
            case 4:
                printf("Atlag: %.2f nap\n", average_days(loans, count));
                break;
            case 5:
                loans = add_loan(loans, &count);
                break;
            case 6:
                free_loans(loans, count);
                printf("Kilepes...\n");
                break;
            default:
                printf("Hibas valasztas!\n");
        }
    } while (choice != 6);
}

/* ===== LISTÁZÁSOK ===== */

void list_all(Loan *loans, int count) {
    for (int i = 0; i < count; i++) {
        printf("%s - %s (%d) %d nap\n",
               loans[i].title,
               loans[i].borrower,
               loans[i].year,
               loans[i].days);
    }
}

void list_2023(Loan *loans, int count) {
    for (int i = 0; i < count; i++) {
        if (loans[i].year == 2023) {
            printf("%s - %s (%d nap)\n",
                   loans[i].title,
                   loans[i].borrower,
                   loans[i].days);
        }
    }
}

void list_long(Loan *loans, int count) {
    for (int i = 0; i < count; i++) {
        if (loans[i].days > 30) {
            printf("%s - %s (%d nap)\n",
                   loans[i].title,
                   loans[i].borrower,
                   loans[i].days);
        }
    }
}

double average_days(Loan *loans, int count) {
    if (count == 0) return 0.0;

    int sum = 0;
    for (int i = 0; i < count; i++) {
        sum += loans[i].days;
    }
    return (double)sum / count;
}

/* ===== ÚJ KÖLCSÖNZÉS ===== */

Loan *add_loan(Loan *loans, int *count) {
    char title[200];
    char borrower[200];
    int year, days;

    getchar();  // ENTER kiszedése

    printf("Konyv cime: ");
    fgets(title, 200, stdin);
    title[strcspn(title, "\n")] = 0;

    printf("Kolcsonzo neve: ");
    fgets(borrower, 200, stdin);
    borrower[strcspn(borrower, "\n")] = 0;

    printf("Ev es napok: ");
    scanf("%d %d", &year, &days);

    if (year < 2000 || days <= 0 || days > 60) {
        printf("Hibas adat!\n");
        return loans;
    }

    Loan *tmp = realloc(loans, (*count + 1) * sizeof(Loan));
    if (!tmp) return loans;
    loans = tmp;

    loans[*count].title = malloc(strlen(title) + 1);
    loans[*count].borrower = malloc(strlen(borrower) + 1);

    strcpy(loans[*count].title, title);
    strcpy(loans[*count].borrower, borrower);

    loans[*count].year = year;
    loans[*count].days = days;

    (*count)++;
    return loans;
}

/* ===== FELSZABADÍTÁS ===== */

void free_loans(Loan *loans, int count) {
    for (int i = 0; i < count; i++) {
        free(loans[i].title);
        free(loans[i].borrower);
    }
    free(loans);
}
